<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>DNSSec | DavidS’ log</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="DNSSec" />
<meta name="author" content="David Schmitt" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Goal Todays excursion goes to enable DNSSEC and DANE on a test domain. This should go a long way towards making my systems more independent and resilient. As a first step I’m going to enable locally validated DNSSEC resolving on my hosts. If I can’t listen, I don’t need to speak. Then I’ll start signing my test zone and when everything goes well, I’ll also add DS records for this domain. The motivation and guidance for this post was brought to you by c’t’s article about DNSSEC and DANE. Enable DNSSEC validation Since I’m running my own ISC Bind installaction, and I do not want to resolve with my authoritative bind, I’ve got to clean up that first. In /etc/bind/named.conf.options add the following: # disable recursion to avoid being open as reflector for DoS attacks recursion no; # only listen on specific NS IPs to allow local resolver to bind to localhost:53 listen-on { 144.76.55.125; }; # no external IPv6. yet. listen-on-v6 { none; }; This keeps bind from blocking the port 53 on localhost needed for the next step: install a dedicated resolver, unbound. The only configuratoin necessary is to configure unbound to only listen on localhost, so that it in turn does not interfere with the authoritative nameserver on the external IP. Note that a restart is required for unbound to change it’s interface bindings. Finally, I can change resolve.conf to point to the new nameserver and dig +dnssec and everyone else now can rely on a trustworthy and fast resolver for DNSSEC. Preparing the zone A little digression: bind can automatically keep all the ephemeral ducks^Wkeys lined up, if told to do so. Luckily, this test zone is static, so I can just enable auto-dnssec maintain; inline-signing yes; and bind will happily ever after keep that zone signed. Except that bind 9.8 (which is the bind in Debian 7) does not yet support inline-signing. A bind, so to say. There is a backport of 9.9, which has introduced inline-signing, so not much is lost here. EXCEPT that the bind9 backport requires an upgraded systemd, and while I do appreciate its features, I do not appreciate unrequested major upgrades on a slow afternoon. So back to the drawing board. The dependency seems to go via the init-system-helpers package, which in this case, is not helping at all. Going from the description, I do not believe that anything there should keep me from staying on systemd 44, except the laziness of the responsible developers. Since this is FLOSS, I count myself the the latter group and start poking at bind’s backported source. Only a “few” minutes later, 1:9.9.5.dfsg-4~bpo70+1~dasz1 is installed, and running, and it already has created a “.signed” file for this zone. In /etc. Preparing the keys I prepared a secure directory, /etc/bind/keys, to store the keying material. Creating the keys seems simple enough: dnssec-keygen -a RSASHA256 -b 2048 -K /etc/bind/keys -n ZONE example.com dnssec-keygen -a RSASHA256 -b 2560 -f KSK -K /etc/bind/keys -n ZONE example.com It will take “a while” though, as dnssec-keygen is using /dev/random and this VM is notoriously starved for entropy. “A while” is now around ten minutes and counting. N.b.: Putting aside the laptop on pattery will lead to unintended disconnects, when it goes to sleep. In the end it took 30 minutes for the first and 101 minutes for the second keypair. Note to self: deploy egd or similar. If bind does not have rights on the key material, it will complain when trying to load them on startup/reload - as I can report from having it tried out. The dnssec-keygen creates the private key mode 0600, so I opted for the simpler method of making the keys owned by the bind runtime user. A more defensive approach would be to let root own the keys and only give g=r rights to the bind runtime group. I might consider that when coding this all up in puppet. Publishing the keys Bind has already done the most tedious work for us: signing the zone and records and it will also keep the signature up to date by recycling the key every 30 days. The final missing piece is to publish our public key in the parent zone, so that everyone has a verifiably trustpath from the DNS root zone to my testing zone’s keys and content. The proper records to add to the parent zone are generated by dnssec-dsfromkey PATH_TO_KSK.key the KSK is obviously the bigger of the two keyfiles, although dsfromkey will happily use the normal key too. I presume it’ll just create a non-functional DS delegation, breaking everything horribly. I’ll try to avoid testing this theory. So, off to the registrar and submit those records! Finishing touches So after deploying the inline-signing to my test zone, nagios noticed that my serial numbers were off between my master and my slave NS. It turns out, that bind does increment the serial number when doing the signing dance. Which is only proper, given that the serial number should be incremented every time something changes in the zone. I’ll need to keep that in mind when doing manual updates." />
<meta property="og:description" content="The Goal Todays excursion goes to enable DNSSEC and DANE on a test domain. This should go a long way towards making my systems more independent and resilient. As a first step I’m going to enable locally validated DNSSEC resolving on my hosts. If I can’t listen, I don’t need to speak. Then I’ll start signing my test zone and when everything goes well, I’ll also add DS records for this domain. The motivation and guidance for this post was brought to you by c’t’s article about DNSSEC and DANE. Enable DNSSEC validation Since I’m running my own ISC Bind installaction, and I do not want to resolve with my authoritative bind, I’ve got to clean up that first. In /etc/bind/named.conf.options add the following: # disable recursion to avoid being open as reflector for DoS attacks recursion no; # only listen on specific NS IPs to allow local resolver to bind to localhost:53 listen-on { 144.76.55.125; }; # no external IPv6. yet. listen-on-v6 { none; }; This keeps bind from blocking the port 53 on localhost needed for the next step: install a dedicated resolver, unbound. The only configuratoin necessary is to configure unbound to only listen on localhost, so that it in turn does not interfere with the authoritative nameserver on the external IP. Note that a restart is required for unbound to change it’s interface bindings. Finally, I can change resolve.conf to point to the new nameserver and dig +dnssec and everyone else now can rely on a trustworthy and fast resolver for DNSSEC. Preparing the zone A little digression: bind can automatically keep all the ephemeral ducks^Wkeys lined up, if told to do so. Luckily, this test zone is static, so I can just enable auto-dnssec maintain; inline-signing yes; and bind will happily ever after keep that zone signed. Except that bind 9.8 (which is the bind in Debian 7) does not yet support inline-signing. A bind, so to say. There is a backport of 9.9, which has introduced inline-signing, so not much is lost here. EXCEPT that the bind9 backport requires an upgraded systemd, and while I do appreciate its features, I do not appreciate unrequested major upgrades on a slow afternoon. So back to the drawing board. The dependency seems to go via the init-system-helpers package, which in this case, is not helping at all. Going from the description, I do not believe that anything there should keep me from staying on systemd 44, except the laziness of the responsible developers. Since this is FLOSS, I count myself the the latter group and start poking at bind’s backported source. Only a “few” minutes later, 1:9.9.5.dfsg-4~bpo70+1~dasz1 is installed, and running, and it already has created a “.signed” file for this zone. In /etc. Preparing the keys I prepared a secure directory, /etc/bind/keys, to store the keying material. Creating the keys seems simple enough: dnssec-keygen -a RSASHA256 -b 2048 -K /etc/bind/keys -n ZONE example.com dnssec-keygen -a RSASHA256 -b 2560 -f KSK -K /etc/bind/keys -n ZONE example.com It will take “a while” though, as dnssec-keygen is using /dev/random and this VM is notoriously starved for entropy. “A while” is now around ten minutes and counting. N.b.: Putting aside the laptop on pattery will lead to unintended disconnects, when it goes to sleep. In the end it took 30 minutes for the first and 101 minutes for the second keypair. Note to self: deploy egd or similar. If bind does not have rights on the key material, it will complain when trying to load them on startup/reload - as I can report from having it tried out. The dnssec-keygen creates the private key mode 0600, so I opted for the simpler method of making the keys owned by the bind runtime user. A more defensive approach would be to let root own the keys and only give g=r rights to the bind runtime group. I might consider that when coding this all up in puppet. Publishing the keys Bind has already done the most tedious work for us: signing the zone and records and it will also keep the signature up to date by recycling the key every 30 days. The final missing piece is to publish our public key in the parent zone, so that everyone has a verifiably trustpath from the DNS root zone to my testing zone’s keys and content. The proper records to add to the parent zone are generated by dnssec-dsfromkey PATH_TO_KSK.key the KSK is obviously the bigger of the two keyfiles, although dsfromkey will happily use the normal key too. I presume it’ll just create a non-functional DS delegation, breaking everything horribly. I’ll try to avoid testing this theory. So, off to the registrar and submit those records! Finishing touches So after deploying the inline-signing to my test zone, nagios noticed that my serial numbers were off between my master and my slave NS. It turns out, that bind does increment the serial number when doing the signing dance. Which is only proper, given that the serial number should be incremented every time something changes in the zone. I’ll need to keep that in mind when doing manual updates." />
<link rel="canonical" href="https://club.black.co.at/log/posts/2014-09-04-dnssec/" />
<meta property="og:url" content="https://club.black.co.at/log/posts/2014-09-04-dnssec/" />
<meta property="og:site_name" content="DavidS’ log" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-09-04T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DNSSec" />
<meta name="twitter:site" content="@dev_el_ops" />
<meta name="twitter:creator" content="@dev_el_ops" />
<script type="application/ld+json">
{"description":"The Goal Todays excursion goes to enable DNSSEC and DANE on a test domain. This should go a long way towards making my systems more independent and resilient. As a first step I’m going to enable locally validated DNSSEC resolving on my hosts. If I can’t listen, I don’t need to speak. Then I’ll start signing my test zone and when everything goes well, I’ll also add DS records for this domain. The motivation and guidance for this post was brought to you by c’t’s article about DNSSEC and DANE. Enable DNSSEC validation Since I’m running my own ISC Bind installaction, and I do not want to resolve with my authoritative bind, I’ve got to clean up that first. In /etc/bind/named.conf.options add the following: # disable recursion to avoid being open as reflector for DoS attacks recursion no; # only listen on specific NS IPs to allow local resolver to bind to localhost:53 listen-on { 144.76.55.125; }; # no external IPv6. yet. listen-on-v6 { none; }; This keeps bind from blocking the port 53 on localhost needed for the next step: install a dedicated resolver, unbound. The only configuratoin necessary is to configure unbound to only listen on localhost, so that it in turn does not interfere with the authoritative nameserver on the external IP. Note that a restart is required for unbound to change it’s interface bindings. Finally, I can change resolve.conf to point to the new nameserver and dig +dnssec and everyone else now can rely on a trustworthy and fast resolver for DNSSEC. Preparing the zone A little digression: bind can automatically keep all the ephemeral ducks^Wkeys lined up, if told to do so. Luckily, this test zone is static, so I can just enable auto-dnssec maintain; inline-signing yes; and bind will happily ever after keep that zone signed. Except that bind 9.8 (which is the bind in Debian 7) does not yet support inline-signing. A bind, so to say. There is a backport of 9.9, which has introduced inline-signing, so not much is lost here. EXCEPT that the bind9 backport requires an upgraded systemd, and while I do appreciate its features, I do not appreciate unrequested major upgrades on a slow afternoon. So back to the drawing board. The dependency seems to go via the init-system-helpers package, which in this case, is not helping at all. Going from the description, I do not believe that anything there should keep me from staying on systemd 44, except the laziness of the responsible developers. Since this is FLOSS, I count myself the the latter group and start poking at bind’s backported source. Only a “few” minutes later, 1:9.9.5.dfsg-4~bpo70+1~dasz1 is installed, and running, and it already has created a “.signed” file for this zone. In /etc. Preparing the keys I prepared a secure directory, /etc/bind/keys, to store the keying material. Creating the keys seems simple enough: dnssec-keygen -a RSASHA256 -b 2048 -K /etc/bind/keys -n ZONE example.com dnssec-keygen -a RSASHA256 -b 2560 -f KSK -K /etc/bind/keys -n ZONE example.com It will take “a while” though, as dnssec-keygen is using /dev/random and this VM is notoriously starved for entropy. “A while” is now around ten minutes and counting. N.b.: Putting aside the laptop on pattery will lead to unintended disconnects, when it goes to sleep. In the end it took 30 minutes for the first and 101 minutes for the second keypair. Note to self: deploy egd or similar. If bind does not have rights on the key material, it will complain when trying to load them on startup/reload - as I can report from having it tried out. The dnssec-keygen creates the private key mode 0600, so I opted for the simpler method of making the keys owned by the bind runtime user. A more defensive approach would be to let root own the keys and only give g=r rights to the bind runtime group. I might consider that when coding this all up in puppet. Publishing the keys Bind has already done the most tedious work for us: signing the zone and records and it will also keep the signature up to date by recycling the key every 30 days. The final missing piece is to publish our public key in the parent zone, so that everyone has a verifiably trustpath from the DNS root zone to my testing zone’s keys and content. The proper records to add to the parent zone are generated by dnssec-dsfromkey PATH_TO_KSK.key the KSK is obviously the bigger of the two keyfiles, although dsfromkey will happily use the normal key too. I presume it’ll just create a non-functional DS delegation, breaking everything horribly. I’ll try to avoid testing this theory. So, off to the registrar and submit those records! Finishing touches So after deploying the inline-signing to my test zone, nagios noticed that my serial numbers were off between my master and my slave NS. It turns out, that bind does increment the serial number when doing the signing dance. Which is only proper, given that the serial number should be incremented every time something changes in the zone. I’ll need to keep that in mind when doing manual updates.","headline":"DNSSec","dateModified":"2014-09-04T00:00:00+00:00","datePublished":"2014-09-04T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://club.black.co.at/log/posts/2014-09-04-dnssec/"},"url":"https://club.black.co.at/log/posts/2014-09-04-dnssec/","author":{"@type":"Person","name":"David Schmitt"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/log/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://club.black.co.at/log/feed.xml" title="DavidS' log" />
    <!-- Google Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-155086367-1', 'auto');
	ga('send', 'pageview', { 'page': location.pathname + location.search + location.hash});
	ga('set', 'anonymizeIp', true);
    </script>
    <!-- End Google Analytics -->
    </head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/log/">DavidS&#39; log</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/log/cv/index.html">DavidS&#39; CV</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">DNSSec</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-09-04T00:00:00+00:00" itemprop="datePublished">Sep 4, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="the-goal">The Goal</h1>

<p>Todays excursion goes to enable DNSSEC and DANE on a test domain. This should
go a long way towards making my systems more independent and resilient.</p>

<p>As a first step I’m going to enable locally validated DNSSEC resolving on my
hosts. If I can’t listen, I don’t need to speak.</p>

<p>Then I’ll start signing my test zone and when everything goes well, I’ll also
add DS records for this domain.</p>

<p>The motivation and guidance for this post was brought to you by
<a href="http://www.ct.de">c’t</a>’s article about <a href="http://www.heise.de/ct/heft/2014-18-DNSSEC-und-DANE-auf-Linux-Servern-konfigurieren-2284734.html">DNSSEC and
DANE</a>.</p>

<h2 id="enable-dnssec-validation">Enable DNSSEC validation</h2>

<p>Since I’m running my own ISC Bind installaction, and I do not want to resolve
with my authoritative bind, I’ve got to clean up that first.</p>

<p>In <code class="language-plaintext highlighter-rouge">/etc/bind/named.conf.options</code> add the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># disable recursion to avoid being open as reflector for DoS attacks
recursion no;
# only listen on specific NS IPs to allow local resolver to bind to localhost:53
listen-on { 144.76.55.125; };
# no external IPv6. yet.
listen-on-v6 { none; };
</code></pre></div></div>

<p>This keeps bind from blocking the port 53 on localhost needed for the next
step: install a dedicated resolver, <a href="http://www.unbound.net/">unbound</a>.</p>

<p>The only configuratoin necessary is to configure unbound to only listen on
localhost, so that it in turn does not interfere with the authoritative
nameserver on the external IP. Note that a <em>restart</em> is required for unbound to
change it’s interface bindings.</p>

<p>Finally, I can change resolve.conf to point to the new nameserver and <code class="language-plaintext highlighter-rouge">dig
+dnssec</code> and everyone else now can rely on a trustworthy and fast resolver for
DNSSEC.</p>

<h2 id="preparing-the-zone">Preparing the zone</h2>

<p>A little digression: bind can automatically keep all the ephemeral ducks^Wkeys
lined up, if told to do so. Luckily, this test zone is static, so I can just enable</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>auto-dnssec maintain;
inline-signing yes;
</code></pre></div></div>

<p>and bind will happily ever after keep that zone signed.</p>

<p>Except that bind 9.8 (which is the bind in Debian 7) does not yet support
inline-signing. A bind, so to say. There is a backport of 9.9, which has
introduced inline-signing, so not much is lost here. <em>EXCEPT</em> that the bind9
backport requires an upgraded systemd, and while I do appreciate its features,
I do not appreciate unrequested major upgrades on a slow afternoon. So back to
the drawing board. The dependency seems to go via the init-system-helpers
package, which in this case, is not helping at all. Going from the description, I do not believe that anything there should keep me from staying on systemd 44, except the laziness of the responsible developers. Since this is FLOSS, I count myself the the latter group and start poking at bind’s backported source.</p>

<p>Only a “few” minutes later, 1:9.9.5.dfsg-4~bpo70+1~dasz1 is installed, and running, and it already has created a “.signed” file for this zone. In /etc.</p>

<h2 id="preparing-the-keys">Preparing the keys</h2>

<p>I prepared a secure directory, <code class="language-plaintext highlighter-rouge">/etc/bind/keys</code>, to store the keying material.
Creating the keys seems simple enough:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dnssec-keygen -a RSASHA256 -b 2048 -K /etc/bind/keys -n ZONE example.com
dnssec-keygen -a RSASHA256 -b 2560 -f KSK  -K /etc/bind/keys -n ZONE example.com
</code></pre></div></div>

<p>It will take “a while” though, as dnssec-keygen is using <code class="language-plaintext highlighter-rouge">/dev/random</code> and this
VM is notoriously starved for entropy. “A while” is now around ten minutes and
counting. N.b.: Putting aside the laptop on pattery <em>will</em> lead to unintended
disconnects, when it goes to sleep. In the end it took 30 minutes for the first
and 101 minutes for the second keypair.</p>

<blockquote>
  <p>Note to self: deploy <a href="http://egd.sourceforge.net/">egd</a> or similar.</p>
</blockquote>

<p>If bind does not have rights on the key material, it will complain when trying
to load them on startup/reload - as I can report from having it tried out. The
dnssec-keygen creates the private key mode 0600, so I opted for the simpler
method of making the keys owned by the bind runtime user. A more defensive
approach would be to let root own the keys and only give g=r rights to the bind
runtime group. I might consider that when coding this all up in puppet.</p>

<h2 id="publishing-the-keys">Publishing the keys</h2>

<p>Bind has already done the most tedious work for us: signing the zone and
records and it will also keep the signature up to date by recycling the key
every 30 days. The final missing piece is to publish our public key in the
parent zone, so that everyone has a verifiably trustpath from the DNS root zone
to my testing zone’s keys and content.</p>

<p>The proper records to add to the parent zone are generated by</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dnssec-dsfromkey PATH_TO_KSK.key
</code></pre></div></div>

<p>the KSK is obviously the bigger of the two keyfiles, although dsfromkey will
happily use the normal key too. I presume it’ll just create a non-functional DS
delegation, breaking everything horribly. I’ll try to avoid testing this
theory.</p>

<p>So, off to the registrar and submit those records!</p>

<h1 id="finishing-touches">Finishing touches</h1>

<p>So after deploying the inline-signing to my test zone, nagios noticed that my
serial numbers were off between my master and my slave NS. It turns out, that
bind does increment the serial number when doing the signing dance. Which is
only proper, given that the serial number should be incremented every time
something changes in the zone. I’ll need to keep that in mind when doing manual
updates.</p>

  </div><a class="u-url" href="/log/posts/2014-09-04-dnssec/index.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/log/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">DavidS&#39; log</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">David Schmitt</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
